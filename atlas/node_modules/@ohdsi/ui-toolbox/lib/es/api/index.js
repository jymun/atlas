'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// @ts-check
var URI = require('urijs');

var STATUS = exports.STATUS = {
  OK: 200,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404
};
var METHODS = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE'
};
var JSON_RESPONSE_TYPE = 'application/json';

/**
 * Class for making AJAX calls
 */

var Api = exports.Api = function () {
  function Api() {
    _classCallCheck(this, Api);

    /** @type string */
    this.apiHost = '';
    /** @type string */
    this.AUTH_TOKEN_HEADER = 'Arachne-Auth-Token';
  }

  _createClass(Api, [{
    key: 'setAuthTokenHeader',


    /**
     * Sets the header to be sent in every AJAX call. This header will contain the token
     * @param {string} header 
     */
    value: function setAuthTokenHeader(header) {
      this.AUTH_TOKEN_HEADER = header;
    }

    /**
     * Sets the host for AJAX calls
     * @param {string} url 
     */

  }, {
    key: 'setApiHost',
    value: function setApiHost(url) {
      this.apiHost = url;
    }
  }, {
    key: 'getUserToken',
    value: function getUserToken() {
      throw new Error('Replace this interface with implementation');
    }

    /**
     * 
     * @param {function} getUserToken 
     */

  }, {
    key: 'setUserTokenGetter',
    value: function setUserTokenGetter(getUserToken) {
      this.getUserToken = getUserToken;
      return this;
    }

    /**
     * Callback to be called when AJAX status is 401 Unauthorized
     * @callback
     */

  }, {
    key: 'handleUnauthorized',
    value: function handleUnauthorized() {
      throw new Error('Replace this interface with implementation');
    }

    /**
     * Sets the unauthorized callback
     * @param {function} handler 
     */

  }, {
    key: 'setUnauthorizedHandler',
    value: function setUnauthorizedHandler(handler) {
      this.handleUnauthorized = handler;
      return this;
    }
  }, {
    key: 'handleUnexpectedError',
    value: function handleUnexpectedError() {
      alert('Oooops!.. Something went wrong :(');
    }
  }, {
    key: 'getHeaders',
    value: function getHeaders(requestUrl) {
      var headers = Object.assign({}, this.headers);
      var token = this.getUserToken();

      if (token) {
        headers[this.AUTH_TOKEN_HEADER] = token;
      }

      return headers;
    }

    /**
     * Checks HTTP status for errors.
     * @param  { {[x: string]: any} } response
     * @return {boolean}
     */

  }, {
    key: 'checkStatusError',
    value: function checkStatusError(response) {
      var status = response.status;

      if (status >= 200 && status < 300) {
        return true;
      }

      switch (status) {
        case STATUS.UNAUTHORIZED:
          this.handleUnauthorized(response.json);
          break;
        default:
          this.handleUnexpectedError();
          break;
      }

      return false;
    }
  }, {
    key: 'sendRequest',
    value: function sendRequest(method, path, payload, callback) {
      var _this = this;

      var params = {
        method: method,
        headers: this.getHeaders(path)
      };

      if (payload && payload instanceof FormData) {
        params.body = payload;
        // NOTE:
        // Do not set 'Content-Type' - browser will automatically do this.
        // Problem is in a 'boundary'.
        // http://stackoverflow.com/questions/39280438/fetch-missing-boundary-in-multipart-form-data-post
      } else if (payload) {
        params.body = JSON.stringify(payload);
        params.headers['Content-Type'] = JSON_RESPONSE_TYPE;
      }

      var fullpath = this.apiHost + path;
      return fetch(fullpath, params).then(function (res) {
        return res.text().then(function (text) {
          return _this.parseResponse(text);
        }).then(function (data) {
          return _this.sendResult(res, data);
        });
      }).then(function (res) {
        return _this.afterRequestHook(res, method, path, callback);
      });
    }

    /**
     * Performs initial sanitizing of the ajax response
     * @param {string} text text returned by ajax
     * @returns any
     */

  }, {
    key: 'parseResponse',
    value: function parseResponse(text) {
      // Protection from empty response
      return text ? JSON.parse(text) : {};
    }

    /**
     * Creates structured object to be used in callback
     * @param {object} res response object returned by fetch
     * @param {any} parsedResponse anything returned by parseResponse
     */

  }, {
    key: 'sendResult',
    value: function sendResult(res, parsedResponse) {
      return { ok: res.ok, status: res.status, json: parsedResponse };
    }
  }, {
    key: 'afterRequestHook',
    value: function afterRequestHook(res, method, path, callback) {
      if (this.checkStatusError(res)) {
        if (typeof callback === 'function') {
          callback(res.json);
        }
      }
      return res.json;
    }
  }, {
    key: 'doGet',
    value: function doGet(path) {
      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments[2];

      // Path with attached GET params
      var pathWithParams = void 0;
      // Callback, taking in account function overloads
      var resolvedCb = void 0;

      if (typeof payload === 'function') {
        // If used function overload: doGet(path, callback)
        pathWithParams = path;
        resolvedCb = payload;
      } else {
        // If used full-version, with passed GET params
        var uri = new URI(path);
        uri.setSearch(payload);

        pathWithParams = uri.toString();
        resolvedCb = callback;
      }

      return this.sendRequest(METHODS.GET, pathWithParams, null, resolvedCb);
    }
  }, {
    key: 'doPost',
    value: function doPost(path, payload, callback) {
      return this.sendRequest(METHODS.POST, path, payload, callback);
    }
  }, {
    key: 'doPut',
    value: function doPut(path, payload, callback) {
      return this.sendRequest(METHODS.PUT, path, payload, callback);
    }
  }, {
    key: 'doDelete',
    value: function doDelete(path, payload, callback) {
      return this.sendRequest(METHODS.DELETE, path, payload, callback);
    }
  }, {
    key: 'headers',
    get: function get() {
      return {
        Accept: JSON_RESPONSE_TYPE
      };
    }
  }]);

  return Api;
}();